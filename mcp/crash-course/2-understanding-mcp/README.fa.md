## قسمت 2: درک MCP در یک سطح فنی

نمای کلی معماری ### MCP

پروتکل زمینه مدل از معماری مشتری-سرور پیروی می کند:
این جدایی نگرانی ها امکان سیستم های مدولار و سازنده را فراهم می کند که در آن هر سرور می تواند روی یک دامنه خاص (مانند دسترسی به فایل ، جستجوی وب یا عملیات پایگاه داده) تمرکز کند.

- ** MCP میزبان **: برنامه هایی مانند Claude Desktop ، Ides یا برنامه Python شما که می خواهند از طریق MCP به داده ها دسترسی پیدا کنند
- ** مشتری MCP **: مشتری های پروتکل که 1: 1 اتصالات را با سرورها حفظ می کنند
- ** سرورهای MCP **: برنامه های سبک وزن که هر یک از آنها قابلیت های خاص را از طریق پروتکل زمینه استاندارد مدل (ابزارها ، منابع ، اعلان ها) قرار می دهند
- ** منابع داده محلی **: پرونده ها ، پایگاه داده ها و خدماتی که سرورهای MCP می توانند به طور ایمن به آنها دسترسی پیدا کنند
- ** خدمات از راه دور **: سیستم های خارجی موجود از طریق اینترنت (به عنوان مثال ، از طریق API) که سرورهای MCP می توانند به آن متصل شوند

این جدایی نگرانی ها امکان سیستم های مدولار و سازنده را فراهم می کند که در آن هر سرور می تواند روی یک دامنه خاص (مانند دسترسی به فایل ، جستجوی وب یا عملیات پایگاه داده) تمرکز کند.

`` `پری دریایی
---
پیکربندی:
موضوع: خنثی
نگاه: کلاسیک
چیدمان: داگر
---
FlowChart LR
رایانه زیرگراف ["رایانه شما"]
مشتری ["میزبان با مشتری MCP <br> (کلود ، IDES ، ابزارها)"]
Servera ["MCP Server A"]
ServerB ["MCP Server B"]
ServerC ["MCP Server C"]
dataA [("منبع داده محلی <br>")]
پایگاه داده [("محلی <br> منبع داده B")]
پایان
اینترنت زیرگراف ["اینترنت"]
Remotec [("سرویس از راه دور <br> C")]
پایان
مشتری -پروتکل MCP -> Servera & ServerB & ServerC
Servera <-> dataA
ServerB <-> پایگاه داده
ServerC -API های وب -> Remotec
`` `

MCP سه ابتدایی اصلی را تعریف می کند که سرورها می توانند پیاده سازی کنند:

1.
2.
3.

برای توسعه دهندگان پایتون ، بلافاصله مفیدترین ابزارهایی است که به LLM ها اجازه می دهد تا اقدامات را به صورت برنامه ای انجام دهند.

### مکانیسم های حمل و نقل شیرجه عمیق

MCP از سه مکانیسم اصلی حمل و نقل پشتیبانی می کند:

1. ** stdio (استاندارد IO) **:
- ارتباطات بر روی جریان های ورودی/خروجی استاندارد رخ می دهد
- وقتی سرور و مشتری در همان دستگاه هستند ، برای ادغام های محلی بهترین است
- تنظیم ساده و بدون پیکربندی شبکه لازم نیست

2. ** SSE (رویدادهای سرور-سرور) **:
-از HTTP برای ارتباطات مشتری به سرور و SSE برای سرور به مشتری استفاده می کند
- مناسب برای اتصالات از راه دور در شبکه ها
- اجازه می دهد تا معماری های توزیع شده

3. ** قابل پخش HTTP ***(معرفی شده در 24 مارس 2025)*:
- حمل و نقل مدرن مبتنی بر HTTP که بر SSE برتری دارد
- از یک نقطه پایانی متحد برای ارتباط دو طرفه استفاده می کند
- ** برای استقرار تولید ** به دلیل عملکرد بهتر و مقیاس پذیری توصیه می شود
- از هر دو حالت عملکردی و بدون تابعیت پشتیبانی می کند

درک اینکه چه زمانی از هر حمل و نقل استفاده کنید برای اجرای موثر MCP بسیار مهم است:

- از ** stdio ** هنگام ساختن ادغام های تک برنامه یا در حین توسعه استفاده کنید
- از ** SSE ** برای توسعه یا هنگام کار با پیاده سازی های قدیمی MCP استفاده کنید
- از ** streamable http ** برای استقرار تولید در جایی که به بهترین عملکرد و مقیاس پذیری نیاز دارید استفاده کنید

#### مقایسه مکانیسم حمل و نقل

`` `پری دریایی
---
پیکربندی:
موضوع: خنثی
نگاه: کلاسیک
چیدمان: داگر
---
FlowChart LR
Subgraph Stdio ["حمل و نقل stdio"]
Client1 ["مشتری MCP"]
سرور 1 ["سرور MCP"]
پایان
زیرگراف SSE ["حمل و نقل SSE"]
Client2 ["مشتری MCP"]
Server2 ["سرور MCP"]
پایان
subgraph streamablehttp ["حمل و نقل قابل پخش HTTP"]
Client3 ["مشتری MCP"]
Server3 ["سرور MCP"]
پایان
Subgraph Local ["استقرار محلیمربی "]
استردو
پایان
از راه دور زیرگراف ["استقرار از راه دور"]
سس
streamablehttp
پایان
client1 -stdin/stdout <br> (دو طرفه) -> سرور 1
client2 -http post <br> (مشتری به سرور) -> سرور 2
Server2 -SSE <br> (سرور به مشتری) -> Client2
Client3 -یکپارچه HTTP <br> (جریان دو طرفه) -> سرور 3
style client1 پر کردن: #bbdefb
Style Server1 Fill: #BBDEFB
style client2 fill: #bbdefb
Style Server2 Fill:#E1Bee7
style client3 fill:#c8e6c9
Style Server3 Fill:#C8E6C9
`` `

اگر با FastAPI آشنا هستید ، متوجه خواهید شد که اجرای یک سرور MCP با HTTP Transports (SSE و HTTP قابل پخش) بسیار مشابه است.هر دو چارچوب از نقاط پایانی HTTP برای دریافت درخواست و پشتیبانی از پاسخ های جریان استفاده می کنند.هر دوی آنها به شما امکان می دهند تا برای مسیرها/نقاط پایانی خاص ، دستگیرندگان را تعریف کرده و الگوهای Async/Await را برای رسیدگی به درخواست ها و ایجاد پاسخ ارائه دهید.این شباهت باعث می شود تا توسعه دهندگان FastAPI بتوانند به ایجاد سرورهای MCP تبدیل شوند ، زیرا می توانند دانش موجود خود را در مورد HTTP ، برنامه نویسی ASYNC و پاسخ های جریان به کار گیرند.

### یک استاندارد جدید

قدرت واقعی MCP در معرفی قابلیت های جدید نیست ، بلکه در استاندارد سازی نحوه قرار گرفتن و مصرف این قابلیت ها است.این چندین مزیت کلیدی را ارائه می دهد:

- ** قابلیت استفاده مجدد **: یک بار سرور بسازید ، از آن با هر مشتری سازگار با MCP استفاده کنید
- ** ترکیب **: برای ایجاد قابلیت های پیچیده چندین سرور را ترکیب کنید
- ** رشد اکوسیستم **: از سرورهای ایجاد شده توسط دیگران بهره مند شوید

اکوسیستم MCP در حال حاضر به سرعت در حال رشد است و سرورهای بسیاری از ابزارها در دسترس هستند.شما می توانید یک مرور کلی در اینجا پیدا کنید: [سرورهای رسمی پشتیبانی شده] (https://github.com/modelContextProtocol/servers)

این بدان معنی است که شما می توانید به جای اختراع چرخ ، سرورهای موجود را اهرم کنید و سرورهای خود را برای بهره مندی از جامعه کمک کنید.