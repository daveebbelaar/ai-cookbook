## قسمت 3: تنظیم سرور ساده با Python SDK

### اولین سرور MCP خود را بسازید

بیایید یک سرور نمایشی ساده با یک ابزار ایجاد کنیم:

`` `پایتون
# server.py
از mcp.server.fastmcp واردات fastmcp

# سرور MCP ایجاد کنید
MCP = FastMCP ("Demoserver")

# ابزار ساده
@mcp.tool ()
def say_hello (نام: str) -> str:
"" "سلام به کسی

استدلال ها:
نام: نام شخص برای سلام
"" "
بازگشت f "سلام ، {نام}! خوشحالم که شما را ملاقات کردم."

# سرور را اجرا کنید
اگر __name__ == "__main__":
mcp.run ()
`` `

### در حال اجرا سرور

روش های مختلفی برای اجرای سرور MCP شما وجود دارد:

#### 1. حالت توسعه با بازرس MCP

ساده ترین راه برای آزمایش سرور شما استفاده از بازرس MCP است:

`` `bash
MCP Dev Server.py
`` `

این سرور شما را به صورت محلی اجرا می کند و آن را به بازرس MCP ، ابزاری مبتنی بر وب متصل می کند که به شما امکان می دهد مستقیماً با ابزارها و منابع سرور خود ارتباط برقرار کنید.این برای آزمایش عالی است.

#### 2. ادغام دسک تاپ کلود

اگر Claude Desktop را نصب کرده اید ، می توانید سرور خود را برای استفاده با Claude نصب کنید:

`` `bash
MCP Server.py را نصب کنید
`` `

با این کار سرور شما به پیکربندی Claude Desktop اضافه می شود و آن را در دسترس Claude قرار می دهد.

#### 3. اجرای مستقیم (فقط مورد نیاز یا SSE)

همچنین می توانید سرور را مستقیماً اجرا کنید:

`` `bash
# روش 1: در حال اجرا به عنوان یک اسکریپت پایتون
Python Server.py

# روش 2: استفاده از UV (توصیه شده)
uv run server.py
`` `

### هنگام اجرای سرور MCP چه اتفاقی می افتد؟

وقتی سرور MCP را اجرا می کنید:

1. سرور با قابلیت هایی که تعریف کرده اید (ابزار ، منابع و غیره) آغاز می شود
2. شروع به گوش دادن به اتصالات در یک حمل و نقل خاص می کند

به طور پیش فرض ، سرورهای MCP از درگاه سرور وب سنتی استفاده نمی کنند.در عوض ، آنها از آنها استفاده می کنند:

- ** Stdio Transport **: سرور از طریق ورودی و خروجی استاندارد ارتباط برقرار می کند (پیش فرض برای "MCP Run" و ادغام با دسک تاپ Claude)
- ** SSE Transport **: برای ارتباطات مبتنی بر HTTP (هنگام پیکربندی صریح استفاده می شود)

اگر می خواهید سرور خود را بر روی HTTP با یک درگاه خاص قرار دهید ، برای استفاده از SSE Transport باید سرور خود را اصلاح کنید:

`` `پایتون
از mcp.server.fastmcp واردات fastmcp

MCP = FastMCP ("MyServer" ، HOST = "127.0.0.1" ، پورت = 8050)

# ابزارها و منابع خود را اینجا اضافه کنید ...

اگر __name__ == "__main__":
# با SSE Transport در بندر 8000 اجرا کنید
MCP.Run (Transport = "SSE")
`` `

سپس می توانید آن را با:

`` `bash
Python Server.py
`` `

این سرور شما را از طریق http: //127.0.0.1: 8050` شروع می کند.

### اجرای سمت مشتری (با استاندارد I/O)

حال ، بیایید ببینیم چگونه مشتری ایجاد کنیم که از سرور ما استفاده کند:

`` `پایتون
واردات asyncio
وارد کردن Nest_Asyncio
از مشتری های واردات MCP ، stdioserverparameters
از mcp.client.stdio واردات stdio_client

async def main ():
# پارامترهای سرور را تعریف کنید
server_params = stdioserverparameters (
Command = "Python" ، # دستور اجرای سرور شما
args = ["server.py"] ، # آرگومان به دستور
)

# به سرور وصل شوید
async با stdio_client (server_params) به عنوان (read_stream ، write_stream):
async با مشتری (read_stream ، write_stream) به عنوان جلسه:
# اتصال را آغاز کنید
Await Session.Initialize ()

# لیست ابزارهای موجود
tools_result = منتظر جلسه. list_tools ()
چاپ ("ابزارهای موجود:")
برای ابزار در Tools_result.tools:
چاپ (f " - {tool.name}: {tool.description}")

# با ابزار ماشین حساب ما تماس بگیرید
نتیجه = منتظر جلسه. call_tool ("افزودن" ، آرگومان = {"a": 2 ، "b": 3})
چاپ (f "2 + 3 = {result.content [0] .text}")


اگر __name__ == "__main__":
asyncio.run (اصلی ())
`` `

این مشتری:

1. از طریق stdio به سرور ما ارتباطی ایجاد می کند
2. یک جلسه MCP ایجاد می کند
3. لیست ابزارهای موجود
4. ابزار `افزودن را با استدلال فراخوانی می کند

### اجرای سمت مشتری (با رویدادهای سرور-سن)

در اینجا نحوه اتصال به سرور خود با SSE آورده شده است:

`` `پایتون
واردات asyncio
وارد کردن Nest_Asyncio
از MCP واردات مشتری
از mcp.client.sse واردات sse_client

async def main ():
# اتصال به tاو سرور با استفاده از SSE
Async با SSE_CLIENT ("http: // localhost: 8050/sse") به عنوان (read_stream ، write_stream):
async با مشتری (read_stream ، write_stream) به عنوان جلسه:
# اتصال را آغاز کنید
Await Session.Initialize ()

# لیست ابزارهای موجود
tools_result = منتظر جلسه. list_tools ()
چاپ ("ابزارهای موجود:")
برای ابزار در Tools_result.tools:
چاپ (f " - {tool.name}: {tool.description}")

# با ابزار ماشین حساب ما تماس بگیرید
نتیجه = منتظر جلسه. call_tool ("افزودن" ، آرگومان = {"a": 2 ، "b": 3})
چاپ (f "2 + 3 = {result.content [0] .text}")


اگر __name__ == "__main__":
asyncio.run (اصلی ())
`` `

### اجرای سمت مشتری (با HTTP قابل پخش) - ** جدید **

> ** توجه داشته باشید **: حمل و نقل HTTP قابل پخش در ** 24 مارس 2025 ** معرفی شده است و اکنون رویکرد ** توصیه شده برای استقرار تولید ** ، با تعویض حمل و نقل SSE است.[در مستندات رسمی بیشتر بدانید] (https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#streamable-http).

** چرا http قابل پخش؟ **

HTTP قابل پخش چندین مزیت نسبت به SSE ارائه می دهد:
- ** عملکرد بهتر **: بهبود 3-5x تحت همزمانی بالا
- ** معماری ساده **: نقطه پایانی به جای نقاط پایانی HTTP + SSE جداگانه
- ** مقیاس پذیری پیشرفته **: پشتیبانی بهتر برای استقرار چند گره
- ** استانداردهای مدرن **: بر اساس استانداردهای جریان فعلی HTTP ساخته شده است

** چگونه کار می کند: **

HTTP قابل پخش از یک نقطه پایانی HTTP (`/MCP`) استفاده می کند که از هر دو حالت عملکرد حالت و بدون تابعیت پشتیبانی می کند.بر خلاف SSE که نیاز به حفظ نقاط پایانی جداگانه دارد ، HTTP قابل پخش یک رابط یکپارچه برای همه ارتباطات MCP فراهم می کند.

در اینجا نحوه اتصال با استفاده از حمل و نقل جدید قابل پخش HTTP آورده شده است:

`` `پایتون
واردات asyncio
وارد کردن Nest_Asyncio
از MCP واردات مشتری
از mcp.client.streamable_http واردات streamablehttp_client

async def main ():
# با استفاده از HTTP قابل پخش به سرور وصل شوید
async با streamablehttp_client ("http: // localhost: 8050/mcp") به عنوان (read_stream ، write_stream ، get_session_id):
async با مشتری (read_stream ، write_stream) به عنوان جلسه:
# اتصال را آغاز کنید
Await Session.Initialize ()

# لیست ابزارهای موجود
tools_result = منتظر جلسه. list_tools ()
چاپ ("ابزارهای موجود:")
برای ابزار در Tools_result.tools:
چاپ (f " - {tool.name}: {tool.description}")

# با ابزار ماشین حساب ما تماس بگیرید
نتیجه = منتظر جلسه. call_tool ("افزودن" ، آرگومان = {"a": 2 ، "b": 3})
چاپ (f "2 + 3 = {result.content [0] .text}")


اگر __name__ == "__main__":
asyncio.run (اصلی ())
`` `

** تفاوت های کلیدی از SSE: **

|** حمل و نقل SSE ** |** حمل و نقل HTTP قابل پخش ** |
| --------------------- | --------------------------------- |
|نقطه پایانی `/Sse` |نقطه پایانی `/MCP` |
|2 مقدار را برمی گرداند: `(بخوانید ، بنویسید)` |3 مقدار را برمی گرداند: `(بخوانید ، بنویسید ، get_session_id)` |
|جداگانه HTTP + SSE جریان |جریان HTTP یکپارچه |
|خوب برای توسعه |** برای تولید توصیه می شود ** |

### کدام رویکرد را باید انتخاب کنید؟

- ** اگر مشتری و سرور شما در همان فرآیند کار می کنند یا اگر فرآیند سرور را مستقیماً از مشتری خود شروع می کنید ، از stdio ** استفاده کنید.
- ** برای استقرار تولید در جایی که به بهترین عملکرد و مقیاس پذیری نیاز دارید ، از http ** قابل استفاده استفاده کنید.
- ** از SSE ** برای توسعه یا هنگام کار با پیاده سازی های قدیمی MCP استفاده کنید که هنوز از HTTP قابل پخش پشتیبانی نمی کنند.

برای بیشتر ادغام های تولیدی با حمایت ، رویکرد ** قابل پخش HTTP ** بهترین عملکرد و معماری مدرن را ارائه می دهد ، در حالی که Stdio ممکن است برای توسعه یا سیستم های محکم و محکم ساده تر باشد.